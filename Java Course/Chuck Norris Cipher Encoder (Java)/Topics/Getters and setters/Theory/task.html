<div class="step-text">
<p>In most cases, a class does not expose its fields to other classes. Instead, it makes its fields accessible through so called <a class="theory-lookup not-relevant" href="/learn/step/3599" rel="noopener noreferrer nofollow" target="_blank" title="In Java, an accessor method, also known as a getter, is a method that allows the value of a field to be read without compromising encapsulation. | By using accessor methods, programmers can control how data is accessed, modify the implementation without affecting other parts of the code, and ensure security by hiding implementation details. Accessor methods only expose the state of an object to other classes while maintaining encapsulation. They are typically used in conjunction with mutator methods, also known as setters, which allow the value of a field to be changed.">accessor methods</a>. They provide encapsulation, which allows you to hide implementation details and control data access, ensuring security. In this topic, you will learn what advantages this approach offers and how to use it properly.</p>
<h5 id="data-encapsulation">Data encapsulation</h5>
<p>According to the <strong><a class="theory-lookup not-relevant" href="/learn/step/3599" rel="noopener noreferrer nofollow" target="_blank" title="In Java, data encapsulation is the practice of wrapping data and the methods that manipulate that data within a single unit, typically a class. | This allows for increased security and control over the data, as well as a more organized code structure. By hiding the implementation details of a class from the outside world, encapsulation promotes modular programming and reduces the risk of data corruption. Additionally, encapsulation can increase code readability and maintainability by providing a clear separation of concerns. Typically, a class does not expose its fields to other classes. Instead, it makes them accessible through special methods called accessor methods, also known as getters and setters. Getters are used to read the field, while setters are used to write to the field. These methods provide encapsulation, which allows you to hide implementation details and control data access, ensuring security. According to the data encapsulation principle, a class's field cannot be directly accessed from other classes.">data encapsulation</a></strong> principle, the fields of a class cannot be directly accessed from other classes. The fields can be accessed only through the methods of that particular class.</p>
<p>To access hidden fields, programmers write special types of methods: <strong><a class="theory-lookup not-relevant" href="/learn/step/3599" rel="noopener noreferrer nofollow" target="_blank" title="In Java, getters are methods used to retrieve and return the value of a field in a class. | They are used to protect and hide the data by providing controlled access to the private fields within a class. Getters are important for data encapsulation, which is the practice of wrapping data and methods that manipulate that data within a single unit, typically a class. This allows for increased security and control over the data, a well-organized code structure, and reduced risk of data corruption. Getters usually contain minimal programming logic and may return non-stored values calculated at runtime.">getters</a></strong> and <strong>setters</strong>. Getters can only read fields, and setters can only write (modify) the fields. Both types of methods should be <code class="language-java">public</code>.</p>
<p>Using these methods gives us some advantages:</p>
<ul><li><p>the fields of a class can be made read-only, write-only, or both;</p></li><li><p>a class can have total control over what values are stored in the fields;</p></li><li><p>users of a class don't know how the class stores its data and don't depend on the fields.</p></li></ul>
<h5 id="getters-and-setters">Getters and setters</h5>
<p>Java doesn't provide any special keywords for getter and setter methods. Their main difference from other methods is their names.</p>
<ul><li><p><strong>getters </strong>start with <strong>get</strong>, followed by the variable name, with the first letter of the <a class="theory-lookup not-relevant" href="/learn/step/3599" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a variable is a named storage location that is used to store a value of a specific type. | It is declared with a specific data type, which determines the kind of value that can be stored in it. Every variable has a unique name, also known as an identifier, which is used to access its value. Variables can be declared and initialized in a single statement, and their value can be accessed and modified using the name. It's important to note that variables can be changed, meaning you can assign a new value to a variable without having to declare it again.">variable</a> name capitalized;</p></li><li><p><strong>setters </strong>start with <strong>set</strong>, followed by the variable name, with the first letter of the variable name capitalized.</p></li></ul>
<p>This convention applies to any type except <code class="language-java">boolean</code>. A <strong>getter</strong> for a boolean field starts with <strong>is</strong>, followed by the variable name.</p>
<p><strong>Example 1.</strong> The class <code class="language-java">Account</code> has four fields: <code class="language-java">id</code>, <code class="language-java">code</code>, <code class="language-java">balance</code> and <code class="language-java">enabled</code>. Each field has a keyword <strong>private</strong> to hide the field from direct access from other classes. Also, the class has <strong>public</strong> getters and setters for accessing fields through these methods.</p>
<pre><code class="language-java">class Account {

    private long id;
    private String code;
    private long balance;
    private boolean enabled;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    public long getBalance() {
        return balance;
    }

    public void setBalance(long balance) {
        this.balance = balance;
    }

    public boolean isEnabled() {
        return enabled;
    }

    public void setEnabled(boolean enabled) {
        this.enabled = enabled;
    }
}</code></pre>
<p>Here you can see the different getters and setters for the class <code class="language-java">Account</code>. Just as the convention states, the boolean field <code class="language-java">enabled</code> has a different getter name: it starts with the word <code class="language-java">is</code> instead of <code class="language-java">get</code>.</p>
<p>Let's create an instance of the class and fill the fields, then read values from the fields and output them.</p>
<pre><code class="language-java">Account account = new Account();

account.setId(1000);
account.setCode("62968503812");
account.setBalance(100_000_000);
account.setEnabled(true);

System.out.println(account.getId());      // 1000
System.out.println(account.getCode());    // 62968503812
System.out.println(account.getBalance()); // 100000000
System.out.println(account.isEnabled());  // true</code></pre>
<p>Sometimes, <strong>getters </strong>or <strong>setters</strong> can contain a more sophisticated logic. For example, <strong>getters</strong> may return non-stored values (calculated at runtime), or <strong>setters</strong> may also in some cases modify the value of another field according to changes. But usually, getters and setters have a minimum of programming logic.</p>
<p><strong>Example 2.</strong> In the following class, the setter <code class="language-java">setName</code> doesn't change the current value if the passed value is <code class="language-java">null</code>.</p>
<pre><code class="language-java">class Patient {

    private String name;

    public Patient(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
    
    public void setName(String name) {
        if (name != null) {
            this.name = name;
        }
    }
}</code></pre>
<h5 id="conclusion">Conclusion</h5>
<p>To restrict access to fields from external code, make them <code class="language-java">private</code> and write suitable <strong>getters/setters</strong> to <strong>read/change </strong>only the fields you need. Do not forget to make use of the <a class="theory-lookup not-relevant" href="/learn/step/3599" rel="noopener noreferrer nofollow" target="_blank" title="In Java, a naming convention is a set of guidelines for naming variables, methods, classes, and other elements in your code. | While these conventions are not strictly enforced by the compiler, they are highly recommended as they make your code more readable and maintainable for both you and other Java programmers. For example, variable names should be descriptive and follow a specific format, such as using camelCase or underscores. Single characters are generally not recommended as variable names, except for temporary or loop variables. Additionally, it is recommended to avoid using special characters in your names, except for a few exceptions such as the dollar sign ($) and underscore (_). By following these conventions, you can create code that is clean, consistent, and easy to understand, which is especially important when working on larger projects with multiple developers.">naming convention</a> when writing them.</p>
<p> </p>
<p>Note, modern IDEs (such as <strong>IntelliJ IDEA</strong>) can generate getters and setters automatically based on class fields.</p>
</div>